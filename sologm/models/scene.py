"""Scene model for SoloGM."""

import uuid
from typing import TYPE_CHECKING, Dict, List, Optional

from sqlalchemy import (
    ForeignKey,
    Integer,
    Text,
    UniqueConstraint,
    select,
)
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import Mapped, mapped_column, relationship, validates

from sologm.models.base import Base, TimestampMixin
from sologm.models.mixins import (
    CountingMixin,
    CrossTableCountConfig,
    DirectCountConfig,
    ExistenceCheckMixin,
    ExistenceConfig,
    FilterCondition,
    FilteredCrossTableCountConfig,
)
from sologm.models.utils import (
    aggregate_cross_relationship_collection,
    get_current_entity,
    get_filtered_collection,
    get_latest_entity,
    slugify,
)

if TYPE_CHECKING:
    from sologm.models.act import (
        Act,
    )  # Added Act for relationship back_populates type hint
    from sologm.models.dice import DiceRoll
    from sologm.models.event import Event
    from sologm.models.game import Game
    from sologm.models.oracle import Interpretation, InterpretationSet


class Scene(ExistenceCheckMixin, CountingMixin, Base, TimestampMixin):
    """SQLAlchemy model representing a scene in a game."""

    __tablename__ = "scenes"
    __table_args__ = (UniqueConstraint("act_id", "slug", name="uix_act_scene_slug"),)

    id: Mapped[str] = mapped_column(primary_key=True, default=lambda: str(uuid.uuid4()))
    slug: Mapped[str] = mapped_column(nullable=False, index=True)
    act_id: Mapped[str] = mapped_column(
        ForeignKey("acts.id", ondelete="CASCADE"), nullable=False
    )
    title: Mapped[str] = mapped_column(nullable=False)
    description: Mapped[Optional[str]] = mapped_column(Text)
    # Status column was removed; is_active flag now indicates the current scene.
    sequence: Mapped[int] = mapped_column(Integer, nullable=False)
    is_active: Mapped[bool] = mapped_column(
        default=False, index=True
    )  # True if this is the current scene being played in its act.

    # Relationships
    events: Mapped[List["Event"]] = relationship(
        "Event",
        back_populates="scene",
        cascade="all, delete-orphan",
        lazy="selectin",  # Consider selectin loading for performance
    )
    interpretation_sets: Mapped[List["InterpretationSet"]] = relationship(
        "InterpretationSet",
        back_populates="scene",
        cascade="all, delete-orphan",
        lazy="selectin",  # Consider selectin loading for performance
    )
    dice_rolls: Mapped[List["DiceRoll"]] = relationship(
        "DiceRoll",
        back_populates="scene",
        cascade="all, delete-orphan",  # Added cascade to match ondelete
        lazy="selectin",  # Use selectin loading for potential performance gain.
    )

    # Define the relationship back to Act within TYPE_CHECKING to avoid
    # circular imports.
    if TYPE_CHECKING:
        act: Mapped["Act"]

        # Properties generated by ExistenceCheckMixin
        has_events: bool
        has_dice_rolls: bool
        has_interpretation_sets: bool

        # Properties generated by CountingMixin
        event_count: int
        dice_roll_count: int
        interpretation_set_count: int
        interpretation_count: int
        selected_interpretation_count: int

    # Configuration for ExistenceCheckMixin to generate has_X properties
    # Import locally to avoid circular import issues
    @staticmethod
    def _get_existence_configs() -> Dict:
        from sologm.models.dice import DiceRoll
        from sologm.models.event import Event
        from sologm.models.oracle import InterpretationSet

        return {
            "events": ExistenceConfig(model=Event, foreign_key="scene_id"),
            "dice_rolls": ExistenceConfig(model=DiceRoll, foreign_key="scene_id"),
            "interpretation_sets": ExistenceConfig(
                model=InterpretationSet, foreign_key="scene_id"
            ),
        }

    _existence_configs = _get_existence_configs()

    # Configuration for CountingMixin to generate X_count properties
    @staticmethod
    def _get_counting_configs() -> Dict:
        from sologm.models.dice import DiceRoll
        from sologm.models.event import Event
        from sologm.models.oracle import Interpretation, InterpretationSet

        return {
            "event": DirectCountConfig(
                model=Event, foreign_key="scene_id", relationship_name="events"
            ),
            "dice_roll": DirectCountConfig(
                model=DiceRoll, foreign_key="scene_id", relationship_name="dice_rolls"
            ),
            "interpretation_set": DirectCountConfig(
                model=InterpretationSet,
                foreign_key="scene_id",
                relationship_name="interpretation_sets",
            ),
            "interpretation": CrossTableCountConfig(
                model=Interpretation,
                foreign_key="set_id",
                relationship_path=["interpretation_sets", "interpretations"],
                relationship_name="interpretation_sets",
            ),
            "selected_interpretation": FilteredCrossTableCountConfig(
                model=Interpretation,
                foreign_key="set_id",
                relationship_path=["interpretation_sets", "interpretations"],
                filter_condition=FilterCondition(field="is_selected", value=True),
                relationship_name="interpretation_sets",
            ),
        }

    _counting_configs = _get_counting_configs()

    # --- Accessor Properties ---

    @property
    def game(self) -> "Game":
        """Get the Game this scene belongs to via the Act relationship.

        Requires the 'act' relationship (and its 'game' relationship) to be loaded.
        """
        if not hasattr(self, "act") or self.act is None:
            # This typically indicates a programming error if accessed when not loaded.
            raise AttributeError(
                "The 'act' relationship is not loaded on this Scene object."
            )
        return self.act.game

    @property
    def game_id(self) -> str:
        """Get the game ID this scene belongs to via the Act relationship.

        Requires the 'act' relationship to be loaded.
        """
        if not hasattr(self, "act") or self.act is None:
            raise AttributeError(
                "The 'act' relationship is not loaded on this Scene object."
            )
        return self.act.game_id

    # --- Latest Item Properties (using loaded relationships) ---

    @property
    def latest_event(self) -> Optional["Event"]:
        """Get the most recently created event from the loaded 'events' collection.

        Returns:
            The most recent Event object, or None if no events are loaded/present.
        """
        return get_latest_entity(self.events)

    @property
    def latest_dice_roll(self) -> Optional["DiceRoll"]:
        """Get the most recently created roll from the loaded 'dice_rolls' collection.

        Returns:
            The most recent DiceRoll object, or None if no rolls are loaded/present.
        """
        return get_latest_entity(self.dice_rolls)

    @property
    def latest_interpretation_set(self) -> Optional["InterpretationSet"]:
        """Get the most recent set from the loaded 'interpretation_sets' collection.

        Returns:
            The most recent InterpretationSet object, or None if no sets are
            loaded/present.
        """
        return get_latest_entity(self.interpretation_sets)

    @property
    def latest_interpretation(self) -> Optional["Interpretation"]:
        """Get the most recent interpretation across all loaded interpretation sets.

        Navigates through loaded 'interpretation_sets' and their 'interpretations'.

        Returns:
            The most recent Interpretation object, or None if no interpretations
            are loaded/present.
        """
        return get_latest_entity(self.all_interpretations)

    # --- Interpretation Set Properties (using loaded relationships) ---

    @property
    def current_interpretation_set(self) -> Optional["InterpretationSet"]:
        """Get the current set from the loaded 'interpretation_sets' collection.

        Filters the loaded collection based on the 'is_current' flag.

        Returns:
            The current InterpretationSet object, or None if none is marked as current.
        """
        return get_current_entity(self.interpretation_sets)

    @property
    def selected_interpretations(self) -> List["Interpretation"]:
        """Get all selected interpretations from loaded interpretation sets.

        Collects interpretations where 'is_selected' is True across loaded sets.

        Returns:
            A list of selected Interpretation objects.
        """
        return get_filtered_collection(self.all_interpretations, "is_selected", True)

    @property
    def all_interpretations(self) -> List["Interpretation"]:
        """Get all interpretations from all loaded interpretation sets.

        Returns:
            A list of all Interpretation objects associated with this scene.
        """
        return aggregate_cross_relationship_collection(
            self, ["interpretation_sets", "interpretations"]
        )

    # --- Validators ---

    @validates("title")
    def validate_title(self, _: str, title: str) -> str:
        """Ensure the scene title is not empty or just whitespace."""
        if not title or not title.strip():
            raise ValueError("Scene title cannot be empty")
        return title.strip()

    @validates("slug")
    def validate_slug(self, _: str, slug: str) -> str:
        """Ensure the scene slug is not empty or just whitespace."""
        if not slug or not slug.strip():
            raise ValueError("Scene slug cannot be empty")
        return slugify(slug)

    # --- Hybrid Properties (for efficient querying) ---
    #
    # Note: has_events, has_dice_rolls, and has_interpretation_sets are now generated
    # by ExistenceCheckMixin via _existence_configs. The complex properties
    # has_interpretations and has_selected_interpretations will be migrated when
    # the mixin supports JOIN operations and filtering conditions.

    # has_events property is now generated by ExistenceCheckMixin

    # has_dice_rolls property is now generated by ExistenceCheckMixin

    # has_interpretation_sets property is now generated by ExistenceCheckMixin

    @hybrid_property
    def has_interpretations(self) -> bool:
        """Check if the scene has any interpretations across all sets.

        Works in Python (checks loaded sets/interpretations) and SQL (uses
        EXISTS subquery).
        """
        return any(iset.interpretations for iset in self.interpretation_sets)

    @has_interpretations.expression
    def has_interpretations(cls):  # noqa: N805
        """SQL expression for checking the existence of related interpretations."""
        from sologm.models.oracle import Interpretation, InterpretationSet

        return (
            select(Interpretation.id)
            .join(InterpretationSet, Interpretation.set_id == InterpretationSet.id)
            .where(InterpretationSet.scene_id == cls.id)
            .exists()
        )

    @hybrid_property
    def has_selected_interpretations(self) -> bool:
        """Check if the scene has any selected interpretations.

        Works in Python (checks loaded interpretations) and SQL (uses EXISTS subquery).
        """
        return any(
            interp.is_selected
            for iset in self.interpretation_sets
            for interp in iset.interpretations
        )

    @has_selected_interpretations.expression
    def has_selected_interpretations(cls):  # noqa: N805
        """SQL expression for checking the existence of selected interpretations."""
        from sologm.models.oracle import Interpretation, InterpretationSet

        return (
            select(Interpretation.id)
            .join(InterpretationSet, Interpretation.set_id == InterpretationSet.id)
            .where(InterpretationSet.scene_id == cls.id)
            .where(Interpretation.is_selected)
            .exists()
        )

    # --- Class Methods ---

    @classmethod
    def create(
        cls, act_id: str, title: str, description: Optional[str], sequence: int
    ) -> "Scene":
        """Create a new scene instance with a unique ID and generated slug.

        Note: This method creates the instance but does not add it to the session.

        Args:
            act_id: ID of the act this scene belongs to.
            title: Title of the scene (will be stripped).
            description: Optional description of the scene (will be stripped
                if provided).
            sequence: Sequence number of the scene within the act.

        Returns:
            A new, transient Scene instance.

        Raises:
            ValueError: If title is empty or whitespace.
        """
        clean_title = title.strip() if title else ""
        if not clean_title:
            raise ValueError("Scene title cannot be empty")

        clean_description = description.strip() if description else None

        scene_slug = f"scene-{sequence}-{slugify(clean_title)}"

        return cls(
            id=str(uuid.uuid4()),
            slug=scene_slug,
            act_id=act_id,
            title=clean_title,
            description=clean_description,
            sequence=sequence,
            # is_active defaults to False via the mapped_column definition.
        )
