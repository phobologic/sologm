"""Act model for SoloGM."""

import uuid
from typing import TYPE_CHECKING, Dict, List, Optional

from sqlalchemy import ForeignKey, Integer, Text, UniqueConstraint, select
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import Mapped, mapped_column, relationship, validates

from sologm.models.base import Base, TimestampMixin
from sologm.models.mixins import (
    CountingMixin,
    CrossTableCountConfig,
    DirectCountConfig,
    ExistenceCheckMixin,
    ExistenceConfig,
    FilteredRelationshipStatusConfig,
    StatusCheckMixin,
)
from sologm.models.utils import (
    aggregate_cross_relationship_collection,
    get_active_entity,
    get_filtered_collection,
    get_first_entity_by_sequence,
    get_latest_entity,
    slugify,
)

if TYPE_CHECKING:
    from sologm.models.dice import DiceRoll
    from sologm.models.event import Event
    from sologm.models.oracle import Interpretation
    from sologm.models.scene import Scene

    # Property generated by ExistenceCheckMixin
    has_scenes: bool

    # Properties generated by CountingMixin
    scene_count: int
    event_count: int
    dice_roll_count: int
    interpretation_count: int

    # Properties generated by StatusCheckMixin
    has_active_scene: bool


class Act(ExistenceCheckMixin, CountingMixin, StatusCheckMixin, Base, TimestampMixin):
    """SQLAlchemy model representing an act in a game."""

    __tablename__ = "acts"
    __table_args__ = (UniqueConstraint("game_id", "slug", name="uix_game_act_slug"),)

    id: Mapped[str] = mapped_column(primary_key=True, default=lambda: str(uuid.uuid4()))
    slug: Mapped[str] = mapped_column(nullable=False, index=True)
    game_id: Mapped[str] = mapped_column(
        ForeignKey("games.id", ondelete="CASCADE"), nullable=False
    )
    title: Mapped[Optional[str]] = mapped_column(
        nullable=True
    )  # Can be null for untitled acts
    summary: Mapped[Optional[str]] = mapped_column(Text, nullable=True)
    sequence: Mapped[int] = mapped_column(Integer, nullable=False)
    is_active: Mapped[bool] = mapped_column(default=False)

    # Relationships this model owns
    scenes: Mapped[List["Scene"]] = relationship(
        "Scene", back_populates="act", cascade="all, delete-orphan"
    )

    # Configuration for ExistenceCheckMixin to generate has_X properties
    # Import locally to avoid circular import issues
    @staticmethod
    def _get_existence_configs() -> Dict:
        from sologm.models.scene import Scene

        return {
            "scenes": ExistenceConfig(model=Scene, foreign_key="act_id"),
        }

    _existence_configs = _get_existence_configs()

    # Configuration for CountingMixin to generate X_count properties
    @staticmethod
    def _get_counting_configs() -> Dict:
        from sologm.models.dice import DiceRoll
        from sologm.models.event import Event
        from sologm.models.oracle import Interpretation
        from sologm.models.scene import Scene

        return {
            "scene": DirectCountConfig(
                model=Scene, foreign_key="act_id", relationship_name="scenes"
            ),
            "event": CrossTableCountConfig(
                model=Event,
                foreign_key="scene_id",
                relationship_path=["scenes", "events"],
                relationship_name="scenes",
            ),
            "dice_roll": CrossTableCountConfig(
                model=DiceRoll,
                foreign_key="scene_id",
                relationship_path=["scenes", "dice_rolls"],
                relationship_name="scenes",
            ),
            "interpretation": CrossTableCountConfig(
                model=Interpretation,
                foreign_key="set_id",
                relationship_path=["scenes", "interpretation_sets", "interpretations"],
                relationship_name="scenes",
            ),
        }

    _counting_configs = _get_counting_configs()

    # Configuration for StatusCheckMixin to generate status properties
    # Import locally to avoid circular import issues
    @staticmethod
    def _get_status_configs() -> Dict:
        from sologm.models.scene import Scene

        return {
            "scene": FilteredRelationshipStatusConfig(
                model=Scene,
                foreign_key="act_id",
                filter_field="is_active",
                filter_value=True,
                relationship_name="scenes",
            ),
        }

    _status_configs = _get_status_configs()

    @validates("slug")
    def validate_slug(self, _: str, slug: str) -> str:
        """Validate the act slug."""
        if not slug or not slug.strip():
            raise ValueError("Act slug cannot be empty")
        return slug

    # --- Hybrid Properties (for efficient querying) ---
    #
    # Note: has_scenes is now generated by ExistenceCheckMixin via _existence_configs.
    # Note: has_active_scene is now generated by StatusCheckMixin via _status_configs.
    # The complex properties has_events, has_dice_rolls, and has_interpretations
    # will be migrated when the mixin supports filtering conditions and JOIN operations.

    # has_scenes property is now generated by ExistenceCheckMixin

    # has_active_scene property is now generated by StatusCheckMixin

    # has_completed_scenes hybrid property removed (status field removed from Scene)

    @property
    def active_scene(self) -> Optional["Scene"]:
        """Get the active scene for this act, if any.

        This property filters the already loaded scenes collection
        and doesn't trigger a new database query.
        """
        return get_active_entity(self.scenes)

    # completed_scenes property removed (status field removed from Scene)
    # active_scenes property removed (use active_scene or filter scenes by is_active)

    @property
    def latest_scene(self) -> Optional["Scene"]:
        """Get the most recently created scene for this act, if any.

        This property sorts the already loaded scenes collection
        and doesn't trigger a new database query.
        """
        return get_latest_entity(self.scenes)

    @hybrid_property
    def has_events(self) -> bool:
        """Check if the act has any events across all scenes.

        Works in both Python and SQL contexts:
        - Python: Checks if all_events is non-empty
        - SQL: Performs a subquery to check for events
        """
        return any(len(scene.events) > 0 for scene in self.scenes)

    @has_events.expression
    def has_events(cls):  # noqa: N805
        """SQL expression for has_events."""
        from sologm.models.event import Event
        from sologm.models.scene import Scene

        return (
            select(1)
            .where((Scene.act_id == cls.id) & (Event.scene_id == Scene.id))
            .exists()
            .label("has_events")
        )

    @property
    def first_scene(self) -> Optional["Scene"]:
        """Get the first scene (by sequence) for this act, if any.

        This property sorts the already loaded scenes collection
        and doesn't trigger a new database query.
        """
        return get_first_entity_by_sequence(self.scenes)

    @property
    def latest_event(self) -> Optional["Event"]:
        """Get the most recently created event across all scenes in this act.

        This property navigates through scenes to find the latest event,
        without triggering new database queries.
        """
        return get_latest_entity(self.all_events)

    @property
    def latest_dice_roll(self) -> Optional["DiceRoll"]:
        """Get the most recently created dice roll across all scenes in this act.

        This property navigates through scenes to find the latest dice roll,
        without triggering new database queries.
        """
        return get_latest_entity(self.all_dice_rolls)

    @hybrid_property
    def has_dice_rolls(self) -> bool:
        """Check if the act has any dice rolls across all scenes.

        Works in both Python and SQL contexts:
        - Python: Checks if all_dice_rolls is non-empty
        - SQL: Performs a subquery to check for dice rolls
        """
        return any(len(scene.dice_rolls) > 0 for scene in self.scenes)

    @has_dice_rolls.expression
    def has_dice_rolls(cls):  # noqa: N805
        """SQL expression for has_dice_rolls."""
        from sologm.models.dice import DiceRoll
        from sologm.models.scene import Scene

        return (
            select(1)
            .where((Scene.act_id == cls.id) & (DiceRoll.scene_id == Scene.id))
            .exists()
            .label("has_dice_rolls")
        )

    @property
    def latest_interpretation(self) -> Optional["Interpretation"]:
        """Get the most recently created interpretation across all scenes in this act.

        This property navigates through scenes and interpretation sets to find
        the latest interpretation, without triggering new database queries.
        """
        return get_latest_entity(self.all_interpretations)

    @hybrid_property
    def has_interpretations(self) -> bool:
        """Check if the act has any interpretations across all scenes.

        Works in both Python and SQL contexts:
        - Python: Checks if all_interpretations is non-empty
        - SQL: Performs a subquery to check for interpretations
        """
        return any(
            any(
                len(interp_set.interpretations) > 0
                for interp_set in scene.interpretation_sets
            )
            for scene in self.scenes
        )

    @has_interpretations.expression
    def has_interpretations(cls):  # noqa: N805
        """SQL expression for has_interpretations."""
        from sologm.models.oracle import Interpretation, InterpretationSet
        from sologm.models.scene import Scene

        return (
            select(1)
            .where(
                (Scene.act_id == cls.id)
                & (InterpretationSet.scene_id == Scene.id)
                & (Interpretation.set_id == InterpretationSet.id)
            )
            .exists()
            .label("has_interpretations")
        )

    @property
    def all_events(self) -> List["Event"]:
        """Get all events across all scenes in this act.

        This property collects events from all scenes without triggering
        new database queries.
        """
        return aggregate_cross_relationship_collection(self, ["scenes", "events"])

    @property
    def all_dice_rolls(self) -> List["DiceRoll"]:
        """Get all dice rolls across all scenes in this act.

        This property collects dice rolls from all scenes without triggering
        new database queries.
        """
        return aggregate_cross_relationship_collection(self, ["scenes", "dice_rolls"])

    @property
    def all_interpretations(self) -> List["Interpretation"]:
        """Get all interpretations across all scenes in this act.

        This property collects interpretations from all scenes without triggering
        new database queries.
        """
        return aggregate_cross_relationship_collection(
            self, ["scenes", "interpretation_sets", "interpretations"]
        )

    @property
    def selected_interpretations(self) -> List["Interpretation"]:
        """Get all selected interpretations across all scenes in this act.

        This property collects selected interpretations from all scenes
        without triggering new database queries.
        """
        return get_filtered_collection(self.all_interpretations, "is_selected", True)

    @classmethod
    def create(
        cls,
        game_id: str,
        title: Optional[str],
        summary: Optional[str],
        sequence: int,
    ) -> "Act":
        """Create a new act with a unique ID and slug.

        Args:
            game_id: ID of the game this act belongs to.
            title: Optional title of the act (can be None for untitled acts).
            summary: Optional summary of the act.
            sequence: Sequence number of the act.
        Returns:
            A new Act instance.
        """
        # Generate a URL-friendly slug from the title and sequence
        # For untitled acts, use a placeholder
        if title:
            act_slug = f"act-{sequence}-{slugify(title)}"
        else:
            act_slug = f"act-{sequence}-untitled"

        return cls(
            id=str(uuid.uuid4()),
            slug=act_slug,
            game_id=game_id,
            title=title,
            summary=summary,
            sequence=sequence,
        )
