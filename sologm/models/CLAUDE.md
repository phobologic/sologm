# Model Development Guidelines

## Primary Reference
Follow the model conventions at [../../conventions/models.md](../../conventions/models.md)

## Key Model Patterns
- **Inheritance**: All models inherit from `Base` and `TimestampMixin`
- **Primary Keys**: Use UUIDs (as strings) with `str(uuid.uuid4())`
- **Relationships**: Define "owning" relationships in model with foreign key
- **Hybrid Properties**: Use for computed properties accessible in both Python and SQL contexts

## Current Model Architecture
```
Game (has acts, active flags)
├── Act (has scenes, cross-scene counts)
│   └── Scene (has events, dice rolls, interpretation sets)
│       ├── Event (belongs to scene, optional interpretation link)
│       ├── DiceRoll (belongs to scene, has reason field)
│       └── InterpretationSet (belongs to scene)
│           └── Interpretation (belongs to set, has selection flag, can link to events)
```

## Mixin System
Uses automated property generation for common patterns:

### ExistenceCheckMixin Usage
```python
class MyModel(Base, TimestampMixin, ExistenceCheckMixin):
    _existence_configs = {
        'items': ExistenceConfig(model='Item', foreign_key='my_model_id'),
        'active_items': ExistenceConfig(
            model='Item', 
            foreign_key='my_model_id',
            filter_condition='is_active=True'
        ),
        'nested_items': ExistenceConfig(
            model='NestedItem',
            foreign_key='my_model_id', 
            relationship_path='items.nested_items'
        )
    }
```

### CountingMixin Usage
For `X_count` hybrid properties:
```python
class MyModel(Base, TimestampMixin, CountingMixin):
    _counting_configs = {
        'items': CountConfig(model='Item', foreign_key='my_model_id'),
        'active_items': CountConfig(
            model='Item',
            foreign_key='my_model_id', 
            filter_condition='is_active=True'
        ),
        'nested_items': CountConfig(
            model='NestedItem',
            foreign_key='my_model_id',
            relationship_path='items.nested_items'  
        )
    }
```

Common count properties in the codebase:
- **Game**: `act_count`
- **Act**: `scene_count`, `event_count`, `dice_roll_count`, `interpretation_count`
- **Scene**: `event_count`, `dice_roll_count`, `interpretation_set_count`, `interpretation_count`, `selected_interpretation_count`
- **Interpretation**: `event_count`  
- **InterpretationSet**: `interpretation_count`

## Model Testing Requirements
- **Test Location**: `sologm/models/tests/test_[model_name]_model.py`
- **Both Contexts**: Test hybrid properties in both Python and SQL contexts
- **SQL Context Example**:
```python
# Test property works in SQL queries
results = session.query(Model).filter(Model.has_items).all()
count_result = session.query(Model.item_count).filter(Model.id == model.id).scalar()
```

## Common Patterns

### Model Creation
```python
@classmethod
def create(cls, param1: str, param2: str) -> "ModelName":
    return cls(
        id=str(uuid.uuid4()),
        param1=param1,
        param2=param2
    )
```

### Hybrid Property for Counts (being replaced by CountingMixin)
```python
@hybrid_property
def item_count(self) -> int:
    return len(self.items)

@item_count.expression
def item_count(cls):
    from sologm.models.item import Item
    return select(func.count(Item.id)).where(Item.parent_id == cls.id).scalar_subquery()
```

## Type Annotations
```python
from typing import TYPE_CHECKING, List, Optional
from sqlalchemy.orm import Mapped, mapped_column, relationship

if TYPE_CHECKING:
    # Generated by mixins (add for IDE support)
    has_items: bool
    item_count: int
```

## Related Conventions
- [Database Access](../../conventions/database_access.md) - Session management with models
- [Testing](../../conventions/testing.md) - Model testing patterns and fixtures
- [Type Annotations](../../conventions/type_annotations.md) - SQLAlchemy `Mapped` types
- [Managers](../../conventions/managers.md) - How managers interact with models
