# SoloGM Database Model Documentation

## Overview of Models and Relationships

```
Game
 └── Acts
     └── Scenes
         ├── Events
         ├── InterpretationSets
         │    └── Interpretations
         │         └── Events (optional link)
         └── DiceRolls
```

## Model Signatures and Fields

### Game
```python
class Game(ExistenceCheckMixin, CountingMixin, StatusCheckMixin, Base, TimestampMixin):
    id: Mapped[str]
    name: Mapped[str]
    slug: Mapped[str]
    description: Mapped[str]
    is_active: Mapped[bool]
    
    # Relationships
    acts: Mapped[List["Act"]]
    
    # Configuration for ExistenceCheckMixin
    _existence_configs = {
        "acts": ExistenceConfig(...)
    }
    
    # Configuration for CountingMixin
    _counting_configs = {
        "act": DirectCountConfig(...)
    }
    
    # Configuration for StatusCheckMixin
    _status_configs = {
        "act": FilteredRelationshipStatusConfig(...)
    }
    
    # Hybrid Properties (work in both Python and SQL)
    # Generated by ExistenceCheckMixin:
    has_acts: bool  # Checks if the game has any acts
    
    # Generated by CountingMixin:
    act_count: int  # Returns the number of acts
    
    # Generated by StatusCheckMixin:
    has_active_act: bool  # Checks if the game has an active act
    
    # Manual implementation (too complex for current StatusCheckMixin):
    @hybrid_property
    def has_active_scene(self) -> bool  # Checks if the game has an active scene (requires both act and scene to be active)
    
    # Removed (Act model doesn't have status field):
    # has_completed_acts: bool  # Would check if the game has any completed acts
    
    # Navigation Properties (using utility functions)
    @property
    def active_act(self) -> Optional["Act"]  # Uses get_active_entity(self.acts)
    
    @property
    def active_scene(self) -> Optional["Scene"]  # Uses cross-navigation through acts
    
    @property
    def completed_acts(self) -> List["Act"]  # Returns all completed acts (not yet using utilities)
    
    @property
    def active_acts(self) -> List["Act"]  # Uses get_filtered_collection(self.acts, "is_active", True)
    
    @property
    def latest_act(self) -> Optional["Act"]  # Uses get_latest_entity(self.acts)
    
    @property
    def latest_scene(self) -> Optional["Scene"]  # Uses aggregate_cross_relationship_collection() + get_latest_entity()
```

### Act
```python
class Act(ExistenceCheckMixin, CountingMixin, StatusCheckMixin, Base, TimestampMixin):
    id: Mapped[str]
    slug: Mapped[str]
    game_id: Mapped[str]
    title: Mapped[Optional[str]]
    summary: Mapped[Optional[str]]
    sequence: Mapped[int]
    is_active: Mapped[bool]
    
    # Relationships
    game: Mapped["Game"]
    scenes: Mapped[List["Scene"]]
    
    # Configuration for ExistenceCheckMixin
    _existence_configs = {
        "scenes": ExistenceConfig(...)
    }
    
    # Configuration for CountingMixin
    _counting_configs = {
        "scene": DirectCountConfig(...),
        "event": CrossTableCountConfig(...),
        "dice_roll": CrossTableCountConfig(...),
        "interpretation": CrossTableCountConfig(...)
    }
    
    # Configuration for StatusCheckMixin
    _status_configs = {
        "scene": FilteredRelationshipStatusConfig(...)
    }
    
    # Hybrid Properties (work in both Python and SQL)
    # Generated by ExistenceCheckMixin:
    has_scenes: bool  # Checks if the act has any scenes
    
    # Generated by CountingMixin:
    scene_count: int  # Returns the number of scenes
    event_count: int  # Returns the total number of events across all scenes
    dice_roll_count: int  # Returns the total number of dice rolls
    interpretation_count: int  # Returns the total number of interpretations
    
    # Generated by StatusCheckMixin:
    has_active_scene: bool  # Checks if the act has an active scene

    # Removed has_completed_scenes

    @hybrid_property
    def has_events(self) -> bool  # Checks if the act has any events across all scenes
    
    @hybrid_property
    def has_dice_rolls(self) -> bool  # Checks if the act has any dice rolls
    
    @hybrid_property
    def has_interpretations(self) -> bool  # Checks if the act has any interpretations
    
    # Navigation Properties (using utility functions)
    @property
    def active_scene(self) -> Optional["Scene"]  # Uses get_active_entity(self.scenes)

    # Removed completed_scenes
    # Removed active_scenes

    @property
    def latest_scene(self) -> Optional["Scene"]  # Uses get_latest_entity(self.scenes)
    
    @property
    def first_scene(self) -> Optional["Scene"]  # Uses get_first_entity_by_sequence(self.scenes)
    
    @property
    def latest_event(self) -> Optional["Event"]  # Uses get_latest_entity(self.all_events)
    
    @property
    def latest_dice_roll(self) -> Optional["DiceRoll"]  # Uses get_latest_entity(self.all_dice_rolls)
    
    @property
    def latest_interpretation(self) -> Optional["Interpretation"]  # Uses get_latest_entity(self.all_interpretations)
    
    @property
    def all_events(self) -> List["Event"]  # Uses aggregate_cross_relationship_collection(self, ['scenes', 'events'])
    
    @property
    def all_dice_rolls(self) -> List["DiceRoll"]  # Uses aggregate_cross_relationship_collection(self, ['scenes', 'dice_rolls'])
    
    @property
    def all_interpretations(self) -> List["Interpretation"]  # Uses aggregation across interpretation sets
    
    @property
    def selected_interpretations(self) -> List["Interpretation"]  # Uses filtered aggregation with is_selected=True
```

### Scene
```python
class Scene(Base, TimestampMixin):
    id: Mapped[str]
    slug: Mapped[str]
    act_id: Mapped[str]
    title: Mapped[str]
    description: Mapped[Optional[str]]
    sequence: Mapped[int]
    is_active: Mapped[bool]
    # Status field removed
    # Relationships
    act: Mapped["Act"]
    events: Mapped[List["Event"]]
    interpretation_sets: Mapped[List["InterpretationSet"]]
    dice_rolls: Mapped[List["DiceRoll"]]
    
    # Hybrid Properties (work in both Python and SQL)
    # Generated by ExistenceCheckMixin:
    has_events: bool  # Checks if the scene has any events
    has_dice_rolls: bool  # Checks if the scene has any dice rolls
    has_interpretation_sets: bool  # Checks if the scene has any interpretation sets
    
    # Generated by CountingMixin:
    event_count: int  # Returns the number of events
    dice_roll_count: int  # Returns the number of dice rolls
    interpretation_set_count: int  # Returns the number of interpretation sets
    interpretation_count: int  # Returns the total number of interpretations
    selected_interpretation_count: int  # Returns the number of selected interpretations
    
    @hybrid_property
    def has_interpretations(self) -> bool  # Checks if the scene has any interpretations
    
    @hybrid_property
    def has_selected_interpretations(self) -> bool  # Checks if the scene has any selected interpretations
    
    # Regular Properties (Python-only)
    @property
    def game(self) -> "Game"  # Returns the game this scene belongs to
    
    @property
    def game_id(self) -> str  # Returns the game ID this scene belongs to
    
    # Navigation Properties (using utility functions)
    @property
    def latest_event(self) -> Optional["Event"]  # Uses get_latest_entity(self.events)
    
    @property
    def latest_dice_roll(self) -> Optional["DiceRoll"]  # Uses get_latest_entity(self.dice_rolls)
    
    @property
    def latest_interpretation_set(self) -> Optional["InterpretationSet"]  # Uses get_latest_entity(self.interpretation_sets)
    
    @property
    def latest_interpretation(self) -> Optional["Interpretation"]  # Uses aggregation across interpretation sets
    
    @property
    def current_interpretation_set(self) -> Optional["InterpretationSet"]  # Uses get_current_entity(self.interpretation_sets)
    
    @property
    def selected_interpretations(self) -> List["Interpretation"]  # Uses filtered aggregation with is_selected=True
    
    @property
    def all_interpretations(self) -> List["Interpretation"]  # Uses aggregation across interpretation sets

    # Removed is_completed
    # Removed is_active_status
```

### Event
```python
class Event(StatusCheckMixin, Base, TimestampMixin):
    id: Mapped[str]
    scene_id: Mapped[str]
    description: Mapped[str]
    source_id: Mapped[int]
    interpretation_id: Mapped[Optional[str]]
    
    # Relationships
    scene: Mapped["Scene"]
    source: Mapped["EventSource"]
    interpretation: Mapped["Interpretation"]
    
    # Status check configurations for StatusCheckMixin
    _status_configs = {
        "from_oracle": RelationshipStatusConfig(...),
        "manual": SourceStatusConfig(...),
        "oracle_generated": SourceStatusConfig(...),
        "dice_generated": SourceStatusConfig(...),
    }
    
    # Hybrid Properties (generated by StatusCheckMixin)
    is_from_oracle: bool  # Checks if this event was created from an oracle interpretation
    is_manual: bool  # Checks if this event was manually created
    is_oracle_generated: bool  # Checks if this event was generated by an oracle
    is_dice_generated: bool  # Checks if this event was generated by a dice roll
    
    # Regular Properties (Python-only)
    @property
    def game(self) -> "Game"  # Returns the game this event belongs to
    
    @property
    def game_id(self) -> str  # Returns the game ID this event belongs to
    
    @property
    def act(self) -> "Act"  # Returns the act this event belongs to
    
    @property
    def act_id(self) -> str  # Returns the act ID this event belongs to
    
    @property
    def source_name(self) -> str  # Returns the name of the event source
    
    @property
    def short_description(self) -> str  # Returns a shortened version of the description
```

### EventSource
```python
class EventSource(Base):
    id: Mapped[int]
    name: Mapped[str]
    
    # No helper properties
```

### InterpretationSet
```python
class InterpretationSet(Base, TimestampMixin):
    id: Mapped[str]
    scene_id: Mapped[str]
    context: Mapped[str]
    oracle_results: Mapped[str]
    retry_attempt: Mapped[int]
    is_current: Mapped[bool]
    
    # Relationships
    scene: Mapped["Scene"]
    interpretations: Mapped[List["Interpretation"]]
    
    # Hybrid Properties (work in both Python and SQL)
    # Generated by CountingMixin:
    interpretation_count: int  # Returns the number of interpretations
    
    @hybrid_property
    def has_selection(self) -> bool  # Checks if any interpretation is selected
    
    # Regular Properties (Python-only)
    @property
    def act(self) -> "Act"  # Returns the act this interpretation set belongs to
    
    @property
    def act_id(self) -> str  # Returns the act ID this interpretation set belongs to
    
    @property
    def game(self) -> "Game"  # Returns the game this interpretation set belongs to
    
    @property
    def game_id(self) -> str  # Returns the game ID this interpretation set belongs to
    
    @property
    def selected_interpretation(self) -> Optional["Interpretation"]  # Returns the selected interpretation
```

### Interpretation
```python
class Interpretation(Base, TimestampMixin):
    id: Mapped[str]
    set_id: Mapped[str]
    title: Mapped[str]
    description: Mapped[str]
    slug: Mapped[str]
    is_selected: Mapped[bool]
    
    # Relationships
    interpretation_set: Mapped["InterpretationSet"]
    events: Mapped[List["Event"]]
    
    # Hybrid Properties (work in both Python and SQL)
    # Generated by ExistenceCheckMixin:
    has_events: bool  # Checks if there are any associated events
    
    # Generated by CountingMixin:
    event_count: int  # Returns the number of associated events
    
    # Regular Properties (Python-only)
    @property
    def scene(self) -> "Scene"  # Returns the scene this interpretation belongs to
    
    @property
    def scene_id(self) -> str  # Returns the scene ID this interpretation belongs to
    
    @property
    def act(self) -> "Act"  # Returns the act this interpretation belongs to
    
    @property
    def act_id(self) -> str  # Returns the act ID this interpretation belongs to
    
    @property
    def game(self) -> "Game"  # Returns the game this interpretation belongs to
    
    @property
    def game_id(self) -> str  # Returns the game ID this interpretation belongs to
    
    @property
    def short_description(self) -> str  # Returns a shortened version of the description
    
    # Navigation Properties (using utility functions)
    @property
    def latest_event(self) -> Optional["Event"]  # Uses get_latest_entity(self.events)
```

### DiceRoll
```python
class DiceRoll(Base, TimestampMixin):
    id: Mapped[str]
    notation: Mapped[str]
    individual_results: Mapped[List[int]]  # Stored as JSON
    modifier: Mapped[int]
    total: Mapped[int]
    reason: Mapped[Optional[str]]
    scene_id: Mapped[Optional[str]]
    
    # Relationships
    scene: Mapped["Scene"]
    
    # Hybrid Properties (work in both Python and SQL)
    @hybrid_property
    def has_reason(self) -> bool  # Checks if this dice roll has a reason
    
    # Regular Properties (Python-only)
    @property
    def act(self) -> Optional["Act"]  # Returns the act this dice roll belongs to
    
    @property
    def act_id(self) -> Optional[str]  # Returns the act ID this dice roll belongs to
    
    @property
    def game(self) -> Optional["Game"]  # Returns the game this dice roll belongs to
    
    @property
    def game_id(self) -> Optional[str]  # Returns the game ID this dice roll belongs to
    
    @property
    def formatted_results(self) -> str  # Returns a formatted string of the dice roll results
    
    @property
    def short_reason(self) -> Optional[str]  # Returns a shortened version of the reason
```

## Key Relationship Chains

1. **Game → Act → Scene**:
   - `Game.acts` → `Act.scenes`

2. **Scene → Events**:
   - `Scene.events` ← `Event.scene_id`

3. **Scene → InterpretationSet → Interpretation**:
   - `Scene.interpretation_sets` → `InterpretationSet.interpretations`

4. **Interpretation → Event** (optional):
   - `Interpretation.events` ← `Event.interpretation_id`

5. **Scene → DiceRoll**:
   - `Scene.dice_rolls` ← `DiceRoll.scene_id`

## Automated Property Generation with Mixins

Many models use mixins to automatically generate common hybrid property patterns, reducing code duplication and improving maintainability.

### ExistenceCheckMixin

Automatically generates `has_X` hybrid properties that check for the existence of related entities.

**Configuration Pattern:**
```python
class MyModel(ExistenceCheckMixin, Base, TimestampMixin):
    _existence_configs = {
        'items': ExistenceConfig(
            model=Item,
            foreign_key='my_model_id'
        ),
    }
    # Automatically generates: has_items property
```

**Generated Properties:**
- **Game**: `has_acts`
- **Act**: `has_scenes`  
- **Scene**: `has_events`, `has_dice_rolls`, `has_interpretation_sets`
- **Interpretation**: `has_events`

### CountingMixin

Automatically generates `X_count` hybrid properties that count related entities.

**Configuration Types:**
- **DirectCountConfig**: For simple direct relationship counts
- **CrossTableCountConfig**: For counts across multiple relationship paths
- **FilteredCountConfig**: For filtered counts on direct relationships
- **FilteredCrossTableCountConfig**: For filtered counts across multiple relationships

**Configuration Pattern:**
```python
class MyModel(CountingMixin, Base, TimestampMixin):
    _counting_configs = {
        'item': DirectCountConfig(
            model=Item,
            foreign_key='my_model_id',
            relationship_name='items'
        ),
        'active_item': FilteredCountConfig(
            model=Item,
            foreign_key='my_model_id',
            filter_condition=FilterCondition(field='is_active', value=True),
            relationship_name='items'
        ),
    }
    # Automatically generates: item_count, active_item_count properties
```

**Generated Properties:**
- **Game**: `act_count`
- **Act**: `scene_count`, `event_count`, `dice_roll_count`, `interpretation_count`
- **Scene**: `event_count`, `dice_roll_count`, `interpretation_set_count`, `interpretation_count`, `selected_interpretation_count`
- **InterpretationSet**: `interpretation_count`
- **Interpretation**: `event_count`

### StatusCheckMixin

Automatically generates `is_X` and `has_active_X` hybrid properties that check for specific status conditions on related entities.

**Configuration Types:**
- **FieldStatusConfig**: For status checks on direct field values in related entities
- **SourceStatusConfig**: For status checks based on values in related source tables
- **CrossTableStatusConfig**: For status checks across multiple relationship paths
- **RelationshipStatusConfig**: For status checks on relationship field conditions
- **FilteredRelationshipStatusConfig**: For filtered existence checks on related entities

**Configuration Pattern:**
```python
class MyModel(StatusCheckMixin, Base, TimestampMixin):
    _status_configs = {
        'manual': SourceStatusConfig(
            source_model=EventSource,
            source_field='source_id',
            source_name_field='name',
            expected_value='manual'
        ),
        'from_oracle': RelationshipStatusConfig(
            field='interpretation_id',
            condition=StatusCondition(condition_type='not_null')
        ),
        'active_item': FilteredRelationshipStatusConfig(
            model=Item,
            foreign_key='my_model_id',
            filter_field='is_active',
            filter_value=True,
            relationship_name='items'
        ),
    }
    # Automatically generates: is_manual, is_from_oracle, has_active_item properties
```

**Status Condition Types:**
- **equals**: Check if field equals a specific value
- **not_null**: Check if field is not null/None
- **source_name**: Check if source name field matches expected value

**Generated Properties:**
- **Event**: `is_from_oracle`, `is_manual`, `is_oracle_generated`, `is_dice_generated`
- **Game**: `has_active_act`
- **Act**: `has_active_scene`

**Property Naming Convention:**
- **SourceStatusConfig**: Generates `is_{config_key}` properties
- **RelationshipStatusConfig**: Generates `is_{config_key}` properties  
- **FieldStatusConfig**: Generates `has_active_{config_key}` properties
- **CrossTableStatusConfig**: Generates `has_active_{config_key}` properties
- **FilteredRelationshipStatusConfig**: Generates `has_active_{config_key}` properties
- **Custom naming**: Use `property_name` parameter to override defaults

### Benefits of Mixin Approach

1. **Eliminates Code Duplication**: No need to manually implement repetitive hybrid property patterns
2. **Consistent Behavior**: All generated properties work identically in Python and SQL contexts
3. **Easy Configuration**: New count/existence properties only require configuration, not code
4. **Type Safety**: Generated properties include type hints for IDE support
5. **Performance**: Generated SQL expressions are optimized for efficiency

## Navigation Property Utilities

To further reduce code duplication, SoloGM models use utility functions for common navigation property patterns. These utilities replace repetitive `@property` implementations with shared, well-tested functions.

### Available Navigation Utilities

The following utility functions are available in `sologm.models.utils`:

#### Basic Entity Finding
- **`get_active_entity(collection)`**: Find the first entity where `is_active = True`
- **`get_latest_entity(collection)`**: Find the most recent entity by `created_at` timestamp
- **`get_first_entity_by_sequence(collection)`**: Find entity with the lowest `sequence` number
- **`get_current_entity(collection)`**: Find the first entity where `is_current = True`

#### Collection Operations
- **`get_filtered_collection(collection, field, value)`**: Filter entities where field equals value
- **`aggregate_cross_relationship_collection(start_entity, path)`**: Collect entities across multiple relationship levels
- **`get_cross_relationship_entity(start_entity, path, filter_func)`**: Navigate through relationships to find a specific entity

### Usage Examples

**Before Consolidation:**
```python
@property
def active_act(self) -> Optional["Act"]:
    return next((act for act in self.acts if act.is_active), None)

@property
def latest_scene(self) -> Optional["Scene"]:
    all_scenes = []
    for act in self.acts:
        all_scenes.extend(act.scenes)
    return max(all_scenes, key=lambda s: s.created_at, default=None)
```

**After Consolidation:**
```python
@property
def active_act(self) -> Optional["Act"]:
    return get_active_entity(self.acts)

@property
def latest_scene(self) -> Optional["Scene"]:
    all_scenes = aggregate_cross_relationship_collection(self, ["acts", "scenes"])
    return get_latest_entity(all_scenes)
```

### Consolidated Navigation Properties

The following navigation properties now use utility functions:

#### Game Model (5 properties)
- `active_act` → uses `get_active_entity(self.acts)`
- `active_scene` → uses cross-navigation through acts
- `active_acts` → uses `get_filtered_collection(self.acts, "is_active", True)`
- `latest_act` → uses `get_latest_entity(self.acts)`
- `latest_scene` → uses `aggregate_cross_relationship_collection()` + `get_latest_entity()`

#### Act Model (10 properties)
- `active_scene` → uses `get_active_entity(self.scenes)`
- `latest_scene` → uses `get_latest_entity(self.scenes)`
- `first_scene` → uses `get_first_entity_by_sequence(self.scenes)`
- `latest_event` → uses `get_latest_entity(self.all_events)`
- `latest_dice_roll` → uses `get_latest_entity(self.all_dice_rolls)`
- `latest_interpretation` → uses `get_latest_entity(self.all_interpretations)`
- `all_events` → uses `aggregate_cross_relationship_collection(self, ['scenes', 'events'])`
- `all_dice_rolls` → uses `aggregate_cross_relationship_collection(self, ['scenes', 'dice_rolls'])`
- `all_interpretations` → uses aggregation across interpretation sets
- `selected_interpretations` → uses filtered aggregation with `is_selected = True`

#### Scene Model (7 properties)
- `latest_event` → uses `get_latest_entity(self.events)`
- `latest_dice_roll` → uses `get_latest_entity(self.dice_rolls)`
- `latest_interpretation_set` → uses `get_latest_entity(self.interpretation_sets)`
- `latest_interpretation` → uses aggregation across interpretation sets
- `current_interpretation_set` → uses `get_current_entity(self.interpretation_sets)`
- `selected_interpretations` → uses filtered aggregation with `is_selected = True`
- `all_interpretations` → uses aggregation across interpretation sets

#### Interpretation Model (1 property)
- `latest_event` → uses `get_latest_entity(self.events)`

### Benefits of Navigation Property Consolidation

1. **Reduced Code Duplication**: ~20 repetitive navigation patterns eliminated
2. **Consistent Implementation**: All navigation follows the same patterns
3. **Improved Maintainability**: Bug fixes and optimizations apply to all properties
4. **Better Testing**: Utility functions are comprehensively tested in isolation
5. **Performance Optimization**: Utilities handle edge cases efficiently
6. **Type Safety**: Utility functions include proper type hints

## Notable Design Patterns

1. **Ownership Hierarchy**: Clear ownership through `cascade="all, delete-orphan"` parameter.

2. **Timestamps**: All models include `created_at` and `modified_at` through `TimestampMixin`.

3. **Slugs**: Most models include a `slug` field for URL-friendly identifiers.

4. **Active Flags**: `is_active` flags track currently active game, act, and scene.

5. **Mixin-Based Property Generation**: Common hybrid property patterns are generated automatically through configuration.

# Removed mention of Status Enums
